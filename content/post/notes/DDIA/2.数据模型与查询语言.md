---
title: "数据模型与查询语言"
date: 2022-02-19T11:13:32+08:00
lastmod: 2022-03-05T09:12:32+08:00
description: ""
draft: false
tags: ["系统设计", "DDIA", "database"]
categories: ["系统设计"]
---

# 数据模型与查询语言

## 数据模型

多数应用使用层层叠加的数据模型来构建，例如：

1. 作为应用开发人员，观察现实世界（其中包括人员、组织、货物、行为、资金流向、传感器等），并通过对象或数据结构，以及操控那些数据结构的 API 来进行建模。这些结构通常是特定于该应用程序。
2. 当需要存储那些数据结构时，可以利用通用数据模型来表示它们，如 JSON 或 XML 文档、关系数据库中的表或图模型。
3. 数据库软件的工程师决定如何以内存、磁盘或网络上的字节来表示 JSON / XML/ 关系 / 图数据。数据表示需要支持多种方式的查询、搜索、操作和处理。
4. 在更低的层次上，硬件工程师则需要考虑用电流、光脉冲、磁场或者其他东西来表示字节的方法。

复杂的应用程序可能会有更多的中间层，但是基本思想相同：**每层都通过提供一个简洁的数据模型来隐藏下层的复杂性。**

### 关系模型与文档模型

#### 数据模型的演变

* **层次模型（`hieranchical model`）**：将所有数据表示为嵌套在记录中的记录树，和 JSON 结构有一些类似。在20世纪70年代 IBM 公司的信息管理系统（IMS）中使用。
* **网状模型（`network model`）**：网状模型由一个称为数据系统语言会议（CODASYL）的委员会进行了标准化，并被数个不同的数据库厂商实现。它也被称为 CODASYL 模型，CODASYL 模型是层次模型的推广。
* **关系模型（`relational model`）**：数据被组织成 **关系**，其中每个关系是 **元组**的无序集合。SQL 基于关系模型，其中 SQL 中的**表**对应关系模型中的关系，**行**对应关系模型中的元组。
* **文档模型（`document-oriented model`）**
* **图模型（`graphical model`）**
* **图模型（`graphical model`）**

#### 对象-关系不匹配

应用层的数据模型和 SQL 数据模型中存在差异，需要一个转换层，模型之间的不连贯有时被称为 **阻抗不匹配（`impedance mismatch`）** ，**对象-关系映射（`ORM，object-relational mapping`）** 框架可以减少转换层的工作量，但是无法完全隐藏两个模型之间的差异。一般来说，**文档模型可以减少应用程序代码和存储层之间的阻抗不匹配**，具有更好的 **局部性（`locality`）**

对于一个像简历这样自包含文档的数据结构而言，JSON 表示是非常合适的。

例：用 JSON 文档表示一个 LinkedIn 简介

```json
{
  "user_id": 251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id": "us:91",
  "industry_id": 131,
  "photo_url": "/p/7/000/253/05b/308dd6e.jpg",
  "positions": [
    {
      "job_title": "Co-chair",
      "organization": "Bill & Melinda Gates Foundation"
    },
    {
      "job_title": "Co-founder, Chairman",
      "organization": "Microsoft"
    }
  ],
  "education": [
    {
      "school_name": "Harvard University",
      "start": 1973,
      "end": 1975
    },
    {
      "school_name": "Lakeside School, Seattle",
      "start": null,
      "end": null
    }
  ],
  "contact_info": {
    "blog": "http://thegatesnotes.com",
    "twitter": "http://twitter.com/BillGates"
  }
}
```

#### 多对一与多对多的关系

对于关系数据库，由于支持联结操作，可以很方便地通过 ID 来引用其他表中的行。而在文档数据库中，一对多的树结构不需要联结，对于联结的支持通常也很弱。

在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同：在这两种情况下，相关项目都被一个唯一的标识符引用，这个标识符在关系模型中被称为 **外键**，在文档模型中称为 **文档引用**。

#### 关系数据库与文档数据库的对比

##### 适合的场景

如果应用数据具有类似文档的结构（即一对多关系树，通常一次性加载整个树），这种场景下适合使用文档模型。

对于使用多对多关系或者高度关联的数据，关系模型可以胜任此场景，但是图模型是最适合的。

##### 模式灵活性

文档数据库有时称为 **无模式（`schemaless`）** ，更精确的术语应该是 **读时模式（`schema-on-read`，数据的结构是隐式的，只有在读取时才解释）**，与 **写时模式（`schema-on-write`，关系数据库的一种传统方法，模式是显式的，并且数据库确保数据写入时都必需遵循）** 相对应。

##### 查询的数据局部性

如果应用程序需要频繁访问整个文档，那么存储局部性会带来性能优势。如果将数据分割到多个表中，则需要进行多次索引查找才能将其全部检索出来，这可能需要更多的磁盘查找并花费更多的时间。

局部性仅仅适用于同时需要文档绝大部分内容的情况。

### 图数据模型

图由两种对象组成：**顶点（`vertex`，也称为节点（`node`）/ 实体（`entity`））** 和 **边（`edge`，也称为关系(`relationship`) / 弧（`arc`））**。

很多数据可以建模为图，图很适合用来处理大量多对多关系的场景，典型的例子包括：

* 社交网络

  顶点是人，边指示哪些人彼此认识。

* web 图

  顶点是网页，边表示与其他页面的 HTML 链接。

* 公路或铁路网

  顶点是交叉路口，边表示它们之间的公路或铁路线路

可以将很多著名的算法运用到这些图上。例如，汽车导航系统搜索道路网络中两点之间的最短路径，PageRank 可以计算 web  图上网页的流行度，从而确定搜索排名。

另外·，图并不局限于以上提到的同构数据，图也提供了单个数据存储区中保存完全不同类型对象的一致性方式。

#### 属性图

在 **属性图模型（`property graph`）**中，

每个顶点包括：

* 唯一的标识符
* 出边的集合（`outgoing edges`）
* 入边的集合（`ingoing edges`）
* 属性的集合（键值对）

每个边包括：

* 唯一的标识符
* 边的起点（尾部顶点，`tail vertex`）
* 边的终点（头部顶点，`head vertex`）
* 描述两个顶点间关系类型的标签
* 属性的集合（键值对）

**使用属性图构建的数据库有 `Neo4j`、`Titan`、`InfiniteGraph` 等。**

### 三元存储模型

在 **三元存储（`triple-store`）** 中，所有信息都以非常简单的三部分形式存储：**主语、谓语、宾语**。

三元组的主语相当于图中的一个顶点。而宾语包括以下两种：

1. 原始数据类型中的值，例如字符串和数字。在这种情况下，三元组的谓语和宾语相当于主语顶点上的属性的键和值。
2. 图中的另一个顶点。此时，谓语是图中的边，主语是尾部顶点，宾语是头部顶点。

### 混合持久化

不同的应用程序有不同的需求，某个用例的最佳技术选择未必适合另一个用例。因此，在可预见的将来，关系数据库可能会继续与各种非关系数据库一起使用 - 这种思路有时也被称为 **混合持久化（`polyglot persistence`）**。

## 数据查询语言

### 命令式与声明式

命令式语言告诉计算机以特定顺序执行某些操作；

声明式查询语言只需指定所需的数据模式，结果需满足什么条件，以及如何转换数据（例如，排序、分组和聚合），而不需指明如何实现这一目标。数据库系统的查询优化器会决定采用哪些索引和联结，以及用何种顺序来执行查询的各个语句。

声明式查询语言比命令式 API 更加简洁易用，更重要的是，**它还隐藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下提高性能。**

**声明式语言对于并行执行更加友好。**

例如查询动物物种列表中的鲨鱼这个场景：

javascript 的写法是这样的：

```javascript
function getSharks() {
    var sharks = [];
    for (var i = 0; i < animals.length; i++) {
        if (animals[i].family === "Sharks") {
            sharks.push(animals[i]);
        }
    }
    return sharks;
}
```

关系代数的写法是这样的：
$$
sharks = σ_{family = "sharks"}(animals)
$$
 SQL 的写法是这样的：

```sql
SELECT * FROM animals WHERE family = 'sharks';
```

### MapReduce 查询

> MapReduce 是一种编程模型，用于在多台机器上批量处理大规模的数据。

MapReduce 既不是一个声明式的查询语言，也不是一个完全命令式的查询 API。
