---
title: "可靠、可扩展与可维护的应用系统"
date: 2022-02-13T11:13:32+08:00
lastmod: 2022-02-13T11:13:32+08:00
description: ""
draft: false
tags: ["系统设计", "DDIA", "database"]
categories: ["系统设计"]
---

# 可靠、可扩展与可维护的应用系统

## 数据密集型应用

> **数据密集型应用（`Data-Intensive Application`)**  的制约因素通常是“数据”，包括数据的规模、数据的复杂度或者数据产生与变化的速率；**计算密集型应用（`Compute-Intensive`）** 的瓶颈通常在CPU。

### 数据系统

数据密集型应用通常也是基于标准模块构建而成，每个模块负责单一的常用功能，这些模块都属于 **数据处理系统（`data systems`）**：

* **数据库（`databases`）** ：存储数据，使得应用可以再次访问
* **高速缓存（`caches`)** ：缓存复杂或操作代价昂贵的结果，以加快下一次访问
* **索引（`search indexes`）** ： 用户可以按关键字搜索数据并支持各种过滤方式
* **流处理（`stream processing`）** ：持续发送消息到另一个进程，处理采用异步的方式
* **批处理（`batch processing`）** ：定期处理大量的累积数据

数据系统之间的界限正在变得模糊，例如 Redis 既可以用于数据存储也可以用于消息队列，Kafka 作为消息队列也具备持久化存储保证。

其次，越来越多的应用程序需求广泛，单个工具不足以满足所有的数据处理和存储需求。因此需要将任务分解，每个组件负责高效完成其中一部分，多个组件依靠应用层代码驱动有机衔接起来。

下图1-1展示了一种数据系统架构：

![图1-1 一种数据系统架构](https://gitee.com/huanghuang927/picture-host/raw/master/20220213102553.png)

### 目标

* **可靠性（`Reliability`）** ： 当出现意外情况如硬件、软件故障、人为失误等，系统应可以继续正常运转并确保功能的正确性
* **可扩展性（`Scalability`）**：也被称为可伸缩性，随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长
* **可维护性（`Maintainability`）**：许多新的人员在不同的生命周期参与到系统开发或者运维，系统都可以合理工作（系统会保持现有行为，并适应新的应用场景）

## 可靠性

### 可靠的定义

* 应用程序执行用户所期望的功能
* 可以容忍用户出现不正确的软件使用方法
* 性能可以应对典型场景、合理的负载压力和数据量
* 系统可以防止任何未经授权的访问和滥用

可靠性大致意味着：即使发生了某些错误，系统仍可以继续正常工作。

### 故障与失效

可能出错的事情称为 **错误（`faults`）** 或故障，系统可以应对错误的特性称为 **容错（`tolerant`）** 或 **弹性（`resilient`）** 。

故障与 **失效（`failure`）** 不完全一致。故障通常被定义为组件偏离正常规格，失效意味着系统作为一个整体停止，无法向用户提供所需的服务。故障不太可能降低到零，因此通常设计容错机制避免从故障引发系统失效。比较重要的事情是**如何在不可靠组件基础上构建可靠性系统**。

#### 硬件故障（`hardware faults`）

在机器足够多的情况，硬件故障的情况迟早会发生。

对于硬件故障的场景，一般采用两种思路去减少系统故障率：

1. 为硬件添加冗余，可以减少单台机器完全失效的概率：

   磁盘配置RAID，服务器配备双电源，热插拔CPU，数据中心添加备用电源、发电机等

2. 增加软件容错的方式

#### 软件故障

* 接受特定的错误输入，便导致所有应用服务器实例崩溃的 BUG
* 失控进程会用尽一些共享资源，包括 CPU 时间、内存、磁盘空间或网络带宽
* 系统依赖的服务变慢，没有响应，或者开始返回错误的响应
* 级联故障，一个组件中的小故障触发另一个组件中的故障，进而触发更多的故障

#### 人为失误

应对的方法有：

* 以最小化出错的方式设计系统，例如精心设计的抽象层、API 和管理后台
* 分离出最容易出错的地方、容易引发故障的接口，提供一个功能齐全但非生产用的沙箱环境
* 充分测试，包括单元测试到全系统集成测试以及手动测试
* 提供快速的回滚恢复机制
* 设置详细而清晰的监控子系统，包括性能指标和错误率
* 推动管理流程并加以培训

## 可扩展性

**可扩展性** 是用来描述系统应对负载增长能力的术语。

### 负载的定义

负载可以用一些称为  **负载参数（`load parameters`）**  的数字来描述。参数的最佳选择取决于系统架构，它可能是 Web 服务器的每秒请求处理次数、数据库中写入的比例、同时活跃的用户数量、缓存命中率等。有时平均值很重要，有时系统瓶颈来自于少数峰值。

### 性能的定义

在系统负载变化的情况下，一般需要从两个方面考虑性能：

1. 负载增加，但系统资源（CPU、内存、网络带宽等）保持不变，系统性能会发生什么变化
2. 负载增加，如果需要保持性能不变，需要增加多少系统资源

对于系统性能的定义，不同类型的系统考虑的角度有很大差异：

对于Hadoop这样的批处理系统，我们通常关心 **吞吐量（`throughput`）**，即每秒可处理的记录条数，或者在特定规模数据集上运行作业的总时间 ；而在线系统通常更看重服务的 **响应时间（`response time`）**，即客户端从发送请求到接收响应之前的间隔。

> **延迟（`latency`）** 和  **响应时间（`response time`）** 的不同：
>
> 响应时间通常指的是客户端看到的，除了**处理请求时间（服务时间，`service time`）** 外，还包括网络延迟和排队延迟；延迟是指某个请求等待处理的持续时长，在此期间它处于 **休眠（`latent`）** 状态，并等待服务返回结果。

#### 响应时间的性能指标

即使不断重复发送相同的请求，每次得到的响应时间也都会有所不同，所以需要将响应时间视为一个可以测量的数值 **分布（`distribution`）**，而不是单个数值。

相比 **算数平均值（`arithmetic mean`）** 而言，用**百分位点（`percentiles`）** 这个指标去得到 **典型（`typical`）** 的响应时间更好。

例如第 95、99 和 99.9 百分位点（缩写为 p95，p99 和 p999）。它们意味着 95%、99% 或 99.9% 的请求响应时间要比该阈值快，例如：如果第 95 百分位点响应时间是 1.5 秒，则意味着 100 个请求中的 95 个响应时间快于 1.5 秒，而 100 个请求中的 5 个响应时间超过 1.5 秒。

采用较高的响应时间百分位数（`tail latencies`，尾部效应或长尾效应）很重要。百分位点通常用于 **服务级别目标（`SLO, service level objectives`）**  和 **服务级别协议（`SLA, service level agreements`）**，即定义服务预期性能和可用性的合同。 SLA 可能会声明，如果服务响应时间的中位数小于 200 毫秒，且 99.9 百分位点低于 1 秒，则认为服务工作正常（如果响应时间更长，就认为服务不达标）。这些指标为客户设定了期望值，并允许客户在 SLA 未达标的情况下要求退款。

**排队延迟（`queueing delay`）** 通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其 CPU 核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 **头部阻塞（`head-of-line blocking`）** 。**当一个请求需要多个后端请求时，单个后端慢请求就会拖慢整个终端用户的请求**

### 如何应对负载增加

通常来说，针对特定级别负载而设计的架构不太可能应付超出预设目标10倍的实际负载，因此当目标服务处于快速增长阶段，需要认真考虑每增加一个数量级的负载，架构如何重新设计。

#### 垂直扩展和水平扩展

* **垂直扩展（`scaling up`，`vertical scaling`）**：升级到更强大的机器
* **水平扩展（`scaling out`，`horizental scaling`）** ：将负载分布到多个更小的机器，跨多台机器分配负载也被称为 **无共享（`shared-nothing`）** 架构。

现实世界中的优秀架构需要将这两种方法务实地结合。

#### 自动扩展与手动扩展

有些系统是 **弹性（`elastic`）** 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动扩展 （人工分析容量并决定向系统添加更多的机器）。如果负载极难预测，则弹性系统可能很有用，但手动扩展系统更简单，并且意外操作可能会更少。

#### 分布式扩展

跨多台机器部署  **无状态服务（`stateless services`）**  非常简单，但将带状态的数据系统从单节点变为分布式配置则可能引入许多额外复杂度。出于这个原因，常识告诉我们应该将数据库放在单个节点上（采用垂直扩展策略），直到高扩展性或者高可用性的需求迫使其不得不改成分布式。

## 可维护性

可维护性一般关注软件系统的三个设计原则：

* **可操作性（`Operability`）**：便于运维团队保持系统平稳运行
* **简单性（`Simplicity`）** ：从系统中消除尽可能多的 **复杂度（`complexity`）**，使新工程师也能轻松理解系统（注意这和用户接口的简单性不一样）
* **可演化性（`evolvability`）** ：使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为 **可伸缩性（`extensibility`）** 、**可修改性（`modifiability`）**  或 **可塑性（`plasticity`）**
