---
title: "InnoDB的索引模型"
description: 
date: 2020-11-03T08:40:31+08:00
lastmod: 2020-11-06T23:22:31+08:00
image: "https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/B_Tree_Structure.png"
math: 
license: MIT
hidden: false
comments: true
draft: false
tags: ["mysql", "innodb"]
categories: ["mysql"]
---

# InnoDB 的索引模型

## 一、前言

## 什么是索引

**索引（`index`）** 的出现是为了提高数据查询的效率，索引的实现一般会使用特定的数据结构，我们可以使用不同的数据结构实现不同的索引模型。

## 索引的常见模型

索引的常见模型有 **哈希表（`hash-table`）** 、**有序数组（`array`）** 和 **搜索树（`search tree`）**。

其中**哈希表适用于只有等值查询的场景**，例如 Memcached 及其他一些 NoSQL 引擎。

**有序数组在等值查询和范围查询场景中的性能都很优秀**，但是对于需要更新数据的场景就显得成本太高，**所以有序数组索引只适用于静态存储引擎** 。

关于搜索树，我们最熟悉的应该是 **二分搜索树（`binary-search tree`）**。如果需要维持 `O(log(N))` 的查询复杂度和更新复杂度，则需要维护这个二分搜索树为平衡二叉树。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“ N 叉 ”树。这里，“ N 叉 ”树中的 `N` 取决于数据块的大小。

## 二、InnoDB 的索引模型

**InnoDB 使用了 B+ 树索引模型**，数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树，每棵 B+ 树的节点都是[索引页](InnoDB%20索引页.md#InnoDB%20索引页)。B+ 树是平衡树，查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度。

### 叶子节点与非叶子节点

B + 树的节点都是索引页，最底层的节点，也即叶子节点被称为 `leaf page` , 非叶子节点被称为`non-leaf page` 或者 `internal page`，所以有时非叶子节点也称为内节点。

叶子节点包含实际的行数据，内节点仅包含指向其他叶子节点或非叶子节点的指针。

其中[记录头信息](InnoDB%20记录存储格式.md#记录头信息)中的一个字段 `record_type` 也可以体现叶子节点和非叶子节点的不同：

* **record_type = 0**: 普通的用户记录（叶子节点中的记录)
* **record_type = 1**: 目录项记录（内节点中的记录）
* **record_type = 2**: Infimum 记录
* **record_type = 3**: Supremum 记录

### 聚簇索引与二级索引

**聚簇索引（`clustered index`)** 也称为主键索引，即用主键列创建的索引都是聚簇索引，其他列创建的索引都是 **二级索引（`secondary index`）** 也即非主键索引。

**两者的主要区别在于聚簇索引的叶子节点存储的是完整的用户记录，而二级索引的叶子节点只存储对应列和主键这两个列的值。**

#### 聚簇索引

聚簇索引以主键值的大小作为页和记录的排序规则。

聚簇索引下的页（包括叶子节点和内节点）内的记录按照主键值的大小顺序排成一个单向链表，页内的记录被划分为若干个组，每个组中主键值最大的记录在页内的偏移量会被当做槽依次存放在页目录中，我们可以通过二分法在页中快速定位到主键列等于某个值的记录。

同一层级各个索引页也是根据页中用户记录的主键值大小顺序排成一个双向链表。

最上层的那个节点为根节点，**内节点页中的每条用户记录对应一个下层节点页，存储对应节点页的页号以及该叶子节点的最小主键值**。

#### 二级索引

二级索引使用对应的索引列的大小进行记录和页的排序。

二级索引下的页（包括叶子节点和内节点）内的记录按照索引列的顺序排成一个单向链表，业内的记录被划分为若干个组，每个组中索引列值最大的记录在页内的偏移量会被当做槽依次存放在页目录中，我们可以通过二分法在页中快速定位到索引列等于某个值的记录。

同一层级各个索引页也是根据页中用户记录的索引列值的大小顺序排成一个双向链表。

最上层的那个节点为根节点，**内节点页中的每条用户记录对应一个下层节点页，存储对应节点页的页号以及该叶子节点的最小索引列值**。

**因为二级索引的叶子节点只存储索引列和主键这两个列的值，所以在需要其他列信息的情况下，需要找到一条符合条件的用户记录就根据此记录的主键信息去聚簇索引重新定位完整的用户记录，这个过程叫做回表。**

#### 联合索引

**联合索引(`multiple-column index`)** 本质也是二级索引，只是索引列由一个列变成多个列，排序按照联合索引列的顺序多列排序。

联合索引只会创建一棵 B+ 树，这和多个列分别创建一个二级索引会创建多棵 B+ 树还是有着本质的不同。

### 创建过程

聚簇索引默认就存在，不需要手动创建。当我们为某个列创建一个 B+ 树索引时，都会为这个索引创建一个根节点页，值得注意的是，**这个根节点页创建之后页号就不会再改变**。在开始没有数据的时候，每个 B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。

随后向表中插入用户记录时，先会把用户记录存储到这个根节点中。在根节点的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页 a 中，然后对这个新页执行 **页分裂** 操作，得到另一个新页 b 。这时新插入的记录会根据键值的大小分配到页 b 或页 a 中。根节点此时便升级为存储目录项记录的页，也就需要把页 a 和页 b 对应的目录项记录插入到根节点中。

## 参考资料

* 小孩子 4919. (2020). _MySQL 是怎样运行的_. 人民邮电出版社.
