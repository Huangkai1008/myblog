---
title: "InnoDB的索引模型"
description: 
date: 2020-11-03T08:40:31+08:00
lastmod: 2020-11-08T11:25:31+08:00
image: "https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/B_Tree_Structure.png"
math: 
license: MIT
hidden: false
comments: true
draft: false
tags: ["mysql", "innodb"]
categories: ["mysql"]
---

# InnoDB 的索引模型

## 一、前言

## 什么是索引

**索引（`index`）** 的出现是为了提高数据查询的效率，索引的实现一般会使用特定的数据结构，我们可以使用不同的数据结构实现不同的索引模型。

## 索引的常见模型

索引的常见模型有 **哈希表（`hash-table`）** 、**有序数组（`array`）** 和 **搜索树（`search tree`）**。

其中**哈希表适用于只有等值查询的场景**，例如 Memcached 及其他一些 NoSQL 引擎。

**有序数组在等值查询和范围查询场景中的性能都很优秀**，但是对于需要更新数据的场景就显得成本太高，**所以有序数组索引只适用于静态存储引擎** 。

关于搜索树，我们最熟悉的应该是 **二分搜索树（`binary-search tree`）**。如果需要维持 `O(log(N))` 的查询复杂度和更新复杂度，则需要维护这个二分搜索树为平衡二叉树。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“ N 叉 ”树。这里，“ N 叉 ”树中的 `N` 取决于数据块的大小。

## 二、InnoDB 的索引模型

**InnoDB 使用了 B+ 树索引模型**，数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树，每棵 B+ 树的节点都是[索引页](InnoDB%20索引页.md#InnoDB%20索引页)。B+ 树是平衡树，查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度。

### 叶子节点与非叶子节点

B + 树的节点都是索引页，最底层的节点，也即叶子节点被称为 `leaf page` , 非叶子节点被称为`non-leaf page` 或者 `internal page`，所以有时非叶子节点也称为内节点。

叶子节点包含实际的行数据，内节点仅包含指向其他叶子节点或非叶子节点的指针。

其中[记录头信息](InnoDB%20记录存储格式.md#记录头信息)中的一个字段 `record_type` 也可以体现叶子节点和非叶子节点的不同：

* **record_type = 0**: 普通的用户记录（叶子节点中的记录)
* **record_type = 1**: 目录项记录（内节点中的记录）
* **record_type = 2**: Infimum 记录
* **record_type = 3**: Supremum 记录

### 聚簇索引与二级索引

**聚簇索引（`clustered index`)** 也称为主键索引，即用主键列创建的索引都是聚簇索引，其他列创建的索引都是 **二级索引（`secondary index`）** 也即非主键索引。

**两者的主要区别在于聚簇索引的叶子节点存储的是完整的用户记录，而二级索引的叶子节点只存储对应列和主键这两个列的值。**

#### 聚簇索引

聚簇索引以主键值的大小作为页和记录的排序规则。

聚簇索引下的页（包括叶子节点和内节点）内的记录按照主键值的大小顺序排成一个单向链表，页内的记录被划分为若干个组，每个组中主键值最大的记录在页内的偏移量会被当做槽依次存放在页目录中，我们可以通过二分法在页中快速定位到主键列等于某个值的记录。

同一层级各个索引页也是根据页中用户记录的主键值大小顺序排成一个双向链表。

最上层的那个节点为根节点，**内节点页中的每条用户记录对应一个下层节点页，存储对应节点页的页号以及该叶子节点的最小主键值**。

#### 二级索引

二级索引使用对应的索引列的大小进行记录和页的排序。

二级索引下的页（包括叶子节点和内节点）内的记录按照索引列的顺序排成一个单向链表，业内的记录被划分为若干个组，每个组中索引列值最大的记录在页内的偏移量会被当做槽依次存放在页目录中，我们可以通过二分法在页中快速定位到索引列等于某个值的记录。

同一层级各个索引页也是根据页中用户记录的索引列值的大小顺序排成一个双向链表。

最上层的那个节点为根节点，**内节点页中的每条用户记录对应一个下层节点页，存储对应节点页的页号以及该叶子节点的最小索引列值**。

**因为二级索引的叶子节点只存储索引列和主键这两个列的值，所以在需要其他列信息的情况下，需要找到一条符合条件的用户记录就根据此记录的主键信息去聚簇索引重新定位完整的用户记录，这个过程叫做回表。**

#### 联合索引

**联合索引(`multiple-column index`)** 本质也是二级索引，只是索引列由一个列变成多个列，排序按照联合索引列的顺序多列排序。

联合索引只会创建一棵 B+ 树，这和多个列分别创建一个二级索引会创建多棵 B+ 树还是有着本质的不同。

### 创建过程

聚簇索引默认就存在，不需要手动创建。当我们为某个列创建一个 B+ 树索引时，都会为这个索引创建一个根节点页，值得注意的是，**这个根节点页创建之后页号就不会再改变**。在开始没有数据的时候，每个 B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。

随后向表中插入用户记录时，先会把用户记录存储到这个根节点中。在根节点的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页 a 中，然后对这个新页执行 **页分裂** 操作，得到另一个新页 b 。这时新插入的记录会根据键值的大小分配到页 b 或页 a 中。根节点此时便升级为存储目录项记录的页，也就需要把页 a 和页 b 对应的目录项记录插入到根节点中。

## 三、InnoDB 索引的应用

### 索引的代价

我们知道，索引可以提高查找数据的效率，除此之外，索引的使用也需要代价，体现在空间和时间两个方面。

#### 索引的空间代价

这个很容易理解，每有一个索引，就需要多一棵 B+ 树。每一棵 B+ 树的每一个节点都是一个索引页，一个索引页默认占用 16KB 的存储空间，一棵巨大的 B+ 树的索引页个数是很可观的，这会占用很大的存储空间。

#### 索引的时间代价

每当对表中的数据进行增删改操作时，都会影响到各个 B+ 树索引。存储引擎需要额外的时间进行页面回收、页分裂等操作来维护索引页和记录的特定顺序。

另外，在[优化器](MySQL的基础架构.md#优化器%20Query%20Optimizer)生成执行计划时需要计算使用不同索引执行查询所需要的成本，越多的索引会使得成本分析过程耗时变长。

### 索引的优化

#### 覆盖索引

**覆盖索引（`covering index`）** 指的是从二级索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。

例如给定一个表 t1 有主键列 id, 索引列 c1, 非索引列 c2，那么对于以下的查询语句 Q1:

```mysql
SELECT * FROM t1 where c1 = 1;
```

这里的 Q1 是用到了 c1 上的索引的，但是因为二级索引的叶子节点上并没有存储 c2 列的值，所以还是需要回表。

假设我们不需要 c2 的值，那么语句可以改成 Q2 这样:

```mysql
SELECT id, c1 FROM t1 where c1 = 1;
```

这样我们就可以通过二级索引直接读取记录，避免了回表，这里就运用到了覆盖索引，当然如果我们需要 c2 列的值同时还需要用到覆盖索引，那么可以建立一个 (c1, c2) 的联合索引。但是正如我们前面提到，索引的建立都是有代价的，因此在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

#### 最左匹配原则

最左匹配原则简要的说，就是一个联合索引的任何最左前缀都可以用于查询。比如有一个联合索引 (`c1`, `c2`, `c3`) ，该索引的所有前缀为（`c1`）、 (`c1`, `c2`)、(`c1`, `c2`, `c3`)，包含这些列的查询都会启用索引查询。

**这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。**

值得注意的是，**索引内的字段顺序极为重要**，假如上面的联合索引改成（`c2`, `c1`, `c3`），那么该索引的前缀就会变为（`c2`）、 (`c2`, `c1`)、(`c2`, `c1`, `c3`)。

对于如何安排索引内的字段顺序，我们有两个原则：

1. 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
比如联合索引(`c1`, `c2`)，那么相当于也维护了(`c1`)这个索引，在没有`c2`的查询下这种是很好的方案。

2. 假设无法减少一个索引的维护，那么可以考虑空间占用较小的方案。
假设我们同时需要 `c1` 和 `c2` 两个列的查询和联合查询，那么我们可以比较 `c1` 和 `c2` 的字段大小，假设 `c1` 的占用空间更小，我们就可以建立两个索引，一个是 (`c2`, `c1`)，一个是 (`c1`)。

#### 索引下推

索引下推（`Index condition pushdown，ICP`)，是在 MySQL5.6 的新特性。举例说明：

给定一个表 t1 有主键列 id, 联合索引（`c1` , `c2`），那么对于以下的查询语句 Q1:

```mysql
SELECT * FROM t1 where c1 like 'a%' and c2 = 10;
```

首选，存储引擎根据联合索引查询所有满足名称以“a”开头的数据，如果未开启 ICP，那么还需要一条条回表到主键索引上找出数据行，再对比字段值。开启 ICP 后，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

个人觉得，加了索引下推逻辑后才是正常的索引匹配逻辑。

#### 设计原则

1. 只为用于搜索、排序或分组的列创建索引。
2. 当列中不重复值的个数在总记录条数中的占比很大时，才为列建立索引。
3. 索引列的类型尽量小。
4. 可以只为索引列前缀创建索引，以减小索引占用的存储空间。
5. 尽量使用覆盖索引进行查询，以避免回表操作带来的性能损耗。
6. 让索引列以列名的形式单独出现在搜索条件中。
7. 为了尽可能少地让聚簇索引发生页分裂的情况，建议让主键自动递增。
8. 定位并删除表中的冗余及重复索引。

## 参考资料

* 小孩子 4919. (2020). _MySQL 是怎样运行的_. 人民邮电出版社.
* [极客时间 - MySQL实战45讲](<林晓斌. (2018, August). MySQL实战45讲. 极客时间. https://time.geekbang.org/column/intro/139>)
