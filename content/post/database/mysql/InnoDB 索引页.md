---
title: "InnoDB 索引页"
description: 
date: 2020-10-27T19:29:31+08:00
lastmod: 2020-10-27T19:29:31+08:00
image: "https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-07-10%2010.15.54.png"
math: 
license: MIT
hidden: false
comments: true
draft: false
tags: ["mysql", "innodb"]
categories: ["mysql"]
---

# InnoDB 索引页

## 一、概述

**索引页(`index page`)** 是 InnoDB 众多页类型中的一种，因为 InnoDB 的特点是 **索引组织表（`Index Organized Table`）** ，所以可以将索引页看成“数据页”。

InnoDB 的索引页组成如下图：

![InnoDB 数据页结构](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-07-10%2010.15.54.png)
可以通过这个表对索引页的各个部分有个基本的了解。

|        名称        |           中文名           | 占用空间大小 |        简单描述        |
|:------------------:|:--------------------------:|:------------:|:----------------------:|
|    File Header     |          文件头部          |    38字节    |    页的一些通用信息    |
|    Page Header     |          页面头部          |    56字节    |  索引页的一些专有信息  |
| Infimum & Supremum | 页面中的最小记录和最大记录 |    26字节    |     两个虚拟的记录     |
|    User Records    |          用户记录          |    不确定    |   用户存储的记录内容   |
|     Free Space     |          空闲空间          |    不确定    |   页中尚未使用的空间   |
|   Page Directory   |           页目录           |    不确定    | 页中某些记录的相对位置 |
|    File Trailer    |          文件尾部          |    8字节     |     校验页是否完整     |


## 二、用户记录的存储

用户存储的记录会按照指定的行格式插入到 **User Records** 部分，但是在开始生成页时，并没有 **User Records** 部分。每当插入一条记录时，都会从 **Free Space** 部分申请一个记录大小的空间并划分到 **User Records** 部分。

我们这里以 Compact 行格式为例来展开一下。

### Infimum & Supremum

InnoDB存储引擎会自动向数据页插入两条记录：**Infimum（最小记录）**、**Supremum（最大记录）** 。这两条记录也被称为伪记录/虚拟记录。

这两条记录的结构十分简单，都是由5个字节的记录头信息和8字节大小的一个固定单词组成。

![Infimum & Supremum](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-07-10%2016.49.37.png)
### 用户记录和[记录头信息](InnoDB%20记录存储格式.md#记录头信息)

#### next_record 字段

`next_record` 表示的是下一条记录的相对位置(地址偏移量)。**但需要注意的是，其并不是指向下一条记录的起始部分，而是指向下一条记录的数据内容的起始部分。**

这个属性值有正负之分，例如第一条记录的 `next_record` 值为 60 （十进制表示）时，则表示从这条记录的真实数据的地址处向后找 60 字节即是下一条记录的真实数据；当第三条记录的 `next_record` 值为 -112 时，则表示从这条记录的真实数据的地址处向前找 112 字节便是上一条记录的真实数据的起始处。

这其实也解释了为什么记录的额外信息部分(变长字段的长度列表、NULL值标志位)是按照列的顺序逆序排列的。因为此时数据内容部分中位置靠前的字段与其所对应的长度信息的相对距离更近。根据 **局部性原理** 可知，此举将可能会提高CPU高速缓存的命中率。

这里我们可以看到， 用户记录的各个行通过这个字段组成了一个 **单向链表** 。**链表的每个节点的后继节点都是下一个比它大的记录，这里的 “大小” 比的是主键的大小，而不是记录插入的前后顺序。当其中记录发生变化(新增、删除、修改)时，该链表也会适时调整，以满足链表按记录按照主键值从小到大的排序规则。**

特别的，针对这个记录链表而言无论其怎么变化，其表头、表尾永远是固定不变的，分别是Infimum 最小记录和 Supremum 最大记录，这也是此两条伪记录的命名来源。**可以看出这两条记录相当于是记录链表的哨兵节点。**

#### heap_no 字段

该字段表示的是记录在本页中的位置。**由于 Infimum最小记录、Supremum最大记录在用户插入的记录的前面，故分别为0、1**。故对于用户记录而言，该值从2开始。假设插入了三条记录，记录主键值分别为1，2， 3，那么记录1、记录2、记录3中该字段的值分别为2、3、4。

#### deleted_flag 字段

该字段为记录删除的标志位。当我们删除某记录时，不是直接从硬盘中删除，而是分为两个阶段：

1. **delete mask 阶段** ： 将该字段的值置为1。
2. **purge 阶段** ：将该记录加入垃圾链表。

对于垃圾链表中记录所占用的空间即为 **可重用空间** 。这样下次当有新的记录添加进来时，即可通过覆盖的方式来复用这部分存储空间。当然，所谓的垃圾链表也是通过被删除记录的`next_record` 字段作为指针来链接形成的。




## 参考资料

* 小孩子 4919. (2020). _MySQL 是怎样运行的_. 人民邮电出版社.