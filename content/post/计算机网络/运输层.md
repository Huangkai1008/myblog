---
title: "运输层"
description: 
date: 2020-08-18T09:21:31+08:00
lastmod: 2020-10-14T12:57:24+08:00
image: "https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/Internet_Protocol_Analysis_-_Transport_Layer.png"
math: 
license: MIT
hidden: false
comments: true
draft: false
tags: ["计算机网络"]
categories: ["计算机网络"]
---
## 一、概述

运输层协议为运行在不同主机上的应用进程之间提供了 **逻辑通信（`logic communication`）** 功能。

通过逻辑通信，运行不同进程的主机好像直接相连一样。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。

### 端口号

端口号是一个16比特的数，其大小在 0 ~ 65535 之间。

0 ~ 1023 范围的端口号称为 **周知端口号（`well-known port number`）** ，是受限制的，这些端口号一般保留给 HTTP 和 FTP 之类的周知应用层协议。

### 多路复用和多路分解

在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为 **多路复用（`multiplexing`）** 。

将运输层报文段中的数据交付到正确的套接字的工作称为 **多路分解（`demultiplexing`）** 。

#### 多路复用的实现

运输层多路复用的要求和实现对应是：

1. 套接字有唯一标识符 -- **源端口号字段（`source port number field`）**

2. 每个报文段有特殊字段来指示该报文段所要交付的字段 -- **目的端口号字段（`destination port number field`）**

#### 多路分解的实现

在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入所连接的进程。

## 二、UDP

UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。

### UDP 的特点

* **UDP 是无连接的，在两个进程通信前没有握手过程。** 因此 UDP 不会引入建立连接的时延。

* **UDP 没有连接状态。** 对应上一点提到的，因为 UDP 是无连接的，所以 UDP 不需要维护连接状态。

* **UDP 提供不可靠数据服务。** 当进程将一个报文发送进 UDP 套接字时，UDP 协议并不保证该报文将到达接收进程。除此之外，UDP 也不能保证报文的到达顺序，意味着到达接收进程的报文可能是乱序到达的。

* **应用层控制可以做到更加精细。** UDP 协议不包括拥塞控制策略，意味着 UDP 的发送端可以用选定的任意速率发送数据。应用层有着更大的实现自由，例如一些实时应用可以使用 UDP ，并作为应用的一部分来实现所需的、超出 UDP 的额外功能。

* **分组首部开销小。** 对比 TCP 协议有着20字节的首部开销，UDP 仅有8字节的首部开销。

### UDP 数据报结构

**UDP 数据报（`UDP datagram`）** 包含 **报头（`datagram header`）** 和 **数据字段(`data section`)** 两部分。

![UDP Datagram](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/UDP%20Datagram.png)

#### UDP 协议头

UDP 协议头包含4个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占16bit，即2个字节。

* **源端口（`source port`）** ：可选字段，它表示发送方进程的端口号，并且应假定为在需要时要回复的端口。
* **目的端口（`target port`）** ：必需字段，数据报接收方的端口号。
* **长度（`length`）** ：协议头和数据报中数据的字节长度。最小长度为8字节，即标头的长度。
* **校验和（`checksum`）**：用于协议头和数据的差错检测。在IPv4中可选，在IPv6中是必需的。

对于如下的一个使用 Wireshark 抓包的例子

![UDP header example](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-04-21%2008.27.44.png)

上述 UDP 首部中四个字段对应的值如下：

|   字段   |    数据     |
|:--------:|:-----------:|
|  源端口  | 0x1f5d=8029 |
| 目的端口 | 0x0747=1863 |
|   长度   |  0x0023=35  |
|  校验和  |   0x9019    |

#### UDP 校验和

UDP 校验和提供了差错检测功能，校验和用于确定当 UDP 报文段从源到目的地移动时，其中的比特是否发生了改变。

发送方的 UDP 对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都会被回卷，得到的结果放在校验和字段。

## 三、可靠数据传输

**可靠数据传输协议（`reliable data transfer protocol`）** 为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付。

我们从简单的场景渐渐过渡到复杂的场景，看如何实现可靠数据传输协议。

### 1. 经完全可靠信道的可靠数据传输：1.0

在这个场景下，我们假设底层信道是完全可靠的，并且接收端的接收速率可以和发送端的发送速率同步。

![rdt 1.0 fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063091894453.jpeg)

rdt 1.0 发送端在收到发送数据的事件（`rdt_send(data)`） 后，把数据分割成一个个分组，并开始发送数据。

rdt 1.0 接收端在收到接收数据的事件（`rdt_rcv(packet)`）后，从分组中提取数据，并把数据发送给上层。

### 2. 经具有比特差错信道的可靠数据传输：2.0

底层信道更为实际的模型是分组中的比特可能受损的模型。在这个场景下，我们还是假设发送的分组依然按序交付。

#### ARQ 协议的定义

在生活中两人打电话的场景也和此场景相近。假设 A 和 B 正在通电话，如果 A 说完一段话后，B 清楚地听到后会回复“好的”，如果 B 觉得 A 讲得含混不清，B 会回复 A “请重复一遍，我没听清”。回复“好的”可以视为 **肯定确认（`positive acknowledgment`）** ，回复“请重复一遍，我没听清楚”可以视为 **否定确认（`negative acknowledgment`）** 。

接收端可以通过这种方式使得发送端知道哪些内容被正确接收，哪些内容接收有误并需要重传。在计算机网络环境中，基于这种机制的可靠数据传输协议称为 **自动重传请求（`Automatic Repeat reQuest, ARQ`）协议** 。

#### ARQ 协议的实现

ARQ 协议需要三种协议功能来实现。

* **差错检测**
和 UDP 的[校验和](运输层.md#UDP%20校验和)功能实现类似，我们可以通过增加校验和字段的方式来实现差错检测。

* **接收方反馈**
在通电话场景下的 ACK （肯定确认） 和 NAK （否定确认）可以实现接收方反馈的功能。

* **重传**
接收方收到有差错的分组时，发送方将重传该分组。

![rdt 2.0 fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063177741459.jpeg)

当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，也即此时`rdt_send`事件不会发生。因此，除非发送端确认接收端已经正确地收到它当前发送的数据，发送端是不会发送新数据的。实现此类行为特征的协议被称为 **停等协议（`stop-and-wait protocol`）** 。

#### 处理ACK/NAK分组受损的场景

rdt 2.0 的实现没有考虑ACK或者NAK分组受损的可能性，在这种场景下，发送端无法知道接收端是否成功接收了上一块发送的数据。

我们的解决方案是在数据分组中增加一个新字段，让发送端对其数据分组编号，即将发送数据分组的 **序列号（`sequence number`）** 放在该字段。

rdt 2.0 作为停止等待协议的一个简单实现，序列号的长度是1位就够了。

![rdt 2.1 sender fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659653383.jpeg)

![rdt 2.1 receiver fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659875543.jpeg)

rdt 2.1 在发送端和接收端均使用了 ACK/NAK，当接收端收到失序分组时，接收端发送 ACK 。当受损分组到达接收端时，接收端发送 NAK。

rdt 2.2 要做的改进是当受损分组到达接收端时，接收端不发送 NAK，取而代之的是发送一个对最近正确收到的数据的 ACK 。这时需要给 ACK 分组也添加序列号，当发送端收到这个 ACK 时，发送端可以根据 ACK 分组的序列号去判断这个 ACK 分组代表的是接收端正确接收了它刚发送的数据亦或是接收端正确接受了它上一次发送的数据。
当发送端收到两个对同一个分组确认的 ACK 时，即收到重复的 ACK ，发送端就可以知道接收端未能正确收到被确认两次的分组的下一个分组。

![rdt 2.2 sender fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063673825018.jpeg)

![rdt 2.2 receiver fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063675189756.jpeg)

### 3. 经具有比特差错的丢包信道的可靠数据运输：3.0

这个场景下底层信道不但会产生比特受损外，还会有丢包的现象。所以协议现在必须处理另外两个关注的问题：

1. 怎么检测丢包
2. 发生丢包后如何处理

发送端可以选择一个合理的时间值，如果在这个时间段内，它没有收到这个分组的 ACK ，则重传该分组。即使在这种情况下引入了 **冗余数组分组（`duplicate data packet`）** 的可能性，但是 rdt 2.2 已经使用序列号处理冗余分组的情况。

实现基于时间的重传机制，需要一个 **倒计数定时器（`countdown timer`）** ，在一个给定的时间量过期后，可中断发送端。因此发送端需要以下功能：

1. 每次发送一个分组（包括第一次分组和重传分组），便启动一个定时器
2. 响应定时器中断（采取适当的动作）
3. 终止定时器

![rdt 3.0 fsm sender](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063717452835.jpeg)

因为分组序号在0和1之间交替，所以 rdt 3.0有时候被称为 **比特交替协议（`alternating-bit protocol`）** 。

### 4. 流水线可靠数据传输协议

rdt 3.0 采用的是停等协议，这样会导致信道的利用率很低，性能会非常差。

![pipelined protocol vs Stop-and-wait protocol](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063749150047.jpeg)

可以使用 **流水线（`pipelining`)** 技术使得分组可以同时发送，以提高性能。实现流水线技术的要点有：

1. **序列号的范围需要增加**，因为每个传送途中（非重传）的分组需要独一无二的序列号，而且同时可能存在多个在传送的未确认报文。
2. **发送端和接收端可能需要缓存多个分组**，发送端至少需要缓存那些已发送但是还未确认的分组，接收端可能需要缓存那些已经正确接收的分组。
3. 所需序列号范围和缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线的差错恢复有两种基本方法：
 a.  **回退 N 步（`Go-Back-N, GBN`）**
 b.  **选择重传（`Selective Repeat, SR`）**

#### 回退N步

在 GBN 协议中，发送端可以在不需要等待收到 ACK 的情况下，同时发送 N 个分组，这意味着发送端最多能保持 N 个未收到 ACK 的分组，N 也被称为滑动窗口的大小。GBN 协议也常被称为 **滑动窗口协议（`sliding-window protocol`）** 。

![Sender's view of sequence numbers in Go-Back-N](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063778631352.jpeg)

`base` 定义为最小的未收到 ACK 的分组的序列号，`nextseqnum` 定义为下一个将被发送的分组的序列号。

区间 [0, base - 1] 定义为已经发送并且已经收到 ACK 的分组序列号。
区间 [base, nextseqnum - 1] 定义为已经发送但是还未收到 ACK 的分组序列号。
区间 [nextseqnum, base + N - 1] 定义为那些要被立刻发送的分组序列号。
区间 [base + N, +∞] 定义为待发送的分组序列号，需要等到序列号为 base 的分组收到 ACK 后，整个滑动窗口向前滑动，base + N 的分组才能被发送。

![GBN sender](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20170727184244495)

当发送端的上层调用 `rdt_send()` 时，发送端首先会检查发送窗口是否已满，如果窗口已满，则拒绝发送分组。当超时事件发生时，发送端启动定时器，且会重新发送所有之前已发送过但未收到 ACK 的分组(即区间 [base, nextseqnum - 1]内的分组）。

当收到某个分组的 ACK 时，还有已被发送且未收到 ACK 的分组，发送端需要重启定时器。如果没有已发送但未被确认的分组，停止该计时器。

![GBN receiver](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/20170727184357967)

假设接收端已经接收到前 n - 1 个分组，那么接收端下一个期待的待接收分组的序列号就为 n 。接收端会丢弃所有下一个到来的序列号非 n 的分组，并重新发送最近收到的分组的 ACK （在这个例子中为：ACK n - 1）。GBN 在这种场景下使用 **累积确认（`cumulative acknowledgments`）** 。

#### 选择重传

GBN 协议潜在地允许发送方用多个分组 “填充流水线” ，因此避免了停等协议中所提到的信道利用率问题。然而 GBN 本身也存在着性能问题，特别是当前网络的带宽延时乘积和滑动窗口 N 都很大时，单个分组的出错就会引起 GBN 重传大量分组，这在大部分情况是没有必要的。随着信道差错率的增加，滑动窗口中便会塞满大量重传的分组。

顾名思义，选择重传协议只会重传一些接收端未正确收到的分组。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。与 GBN 不同的是，它的滑动窗口中会包含一些被 ACK 过的分组。

![选择重传（SR) 发送端与接收端的序号空间](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063950129010.jpeg)

SR 接收端将确认一个正确接收的分组而不管其是否是按序的。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）都被收到为止。例如发送端发送了5个分组，序列号分别为 {0, 1, 2, 3, 4}，但是分组 0 丢失了，其它4个分组被成功接收。那么这4个分组将被接收端缓存，并且发送相应的 ACK 给发送端，然后等待分组0，当分组0重传并且成功收到后，接收端将会把这5个分组一起交付给上层。

SR 协议中发送端的事件与动作包括：

1. **从上层收到数据** 。当从上层接收到数据后，SR 发送端检查下一个可用于该分组的序号。如果序号位于发送端的滑动窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将分组缓存，要么将其返回给上层以便以后传输。
2. **超时** 。这里再次使用定时器防止丢失分组。在这个场景下需要每个分组拥有自己的逻辑定时器，因为超时发生后只能发送一个分组。可以使用单个硬件定时器模拟多个逻辑定时器的操作。
3. **收到 ACK** 。如果收到 ACK ，倘若该分组序号在窗口内，则 SR 发送端将那个被确认的分组标记为已接收。如果该分组的序号等于 `send_base` ，则窗口基序号向前移动到具有最小序号的未确定分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。

SR 协议中接收端的事件与动作包括：

1. **序号在 [rcv_base, rcv_base + N - 1] 内的分组被正确接收。** 在此情况下，收到的分组落在接收端的窗口内，一个选择 ACK 被会送给发送端。如果该分组以前未被收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号（`rcv_base`） ，则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。
2. **序号在 [rcv_base - N, rcv_base - 1] 内的分组被正确接收。** 在此情况下，必须产生一个 ACK ，即使该分组是接收端以前已经确认过的分组。
3. **其他情况。** 忽略该分组。

**值得注意的是，对于 SR 协议而言，窗口大小必须小于等于序号空间大小的一半。**

## 四、TCP

### TCP 的特点

#### 面向连接

TCP 是 **面向连接的（`connection-oriented`）** ，即在一个应用进程在向另一个应用进程发送数据之前，这两个进程必须要相互**握手（`handshake`）** 。握手的意思是它们相互发送某些预备报文段，以建立确保数据传输的参数。作为 TCP 连接建立的一部分，连接的双方都将初始化与 TCP 连接相关的许多 TCP 状态变量。

值得注意的是，TCP 连接指的不是一条像在[电路交换](计算机网络.md#电路交换（%20circuit%20switching%20）)网络中的端到端 TDM 或 FDM 电路。**这里的 “连接” 是一条逻辑连接，其共同状态仅保留在两个通信端系统的 TCP 程序中。**

#### 全双工服务

TCP 连接提供的是 **全双工服务（`full-duplex service`）** ,  如果一台主机上的进程 B 存在一条 TCP 连接，那么应用层数据就可在从进程 B 流向 进程 A 的同时，也从进程 A 流向 进程 B。

#### 点对点通信

TCP 连接总是 **点对点的（`point-to-point`）** ，即 TCP 连接总存在于单个发送方和单个接收方之间。

#### 面向字节流

TCP 把数据看作一个无结构的、有序的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给予确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。

TCP 可从缓存中取出并放入报文段中的数据数量受限于 **最大报文段长度（`Maximum Segment Size, MSS`）** 。

### TCP 的组成

TCP 连接包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。

### TCP 报文段结构

**TCP 报文段（`TCP segment`）** 包含 **报文首部（`segment header`）** 和 **数据字段（`data section`）** 两部分。

#### TCP 报文首部

TCP 报文首部和[UDP 协议头](#UDP%20协议头)一样包含以下字段：

* **源端口（`source port`）**
* **目的端口（`target port`）**
* **校验和（`checksum`）**

除此以外 TCP 报文首部还包含以下字段：

* **序号（`sequence number`）** 和 **确认号（`acknowledgment number`）** ：长度都是32bit，被 TCP 发送方和接收方用于实现可靠数据传输服务。
* **窗口大小（`receive window size`）** ：接收窗口的大小，长度为16bit，此字段指示接收方愿意接受的字节数量。
* **首部长度（`Data offset`）**：长度为4bit，以32bit为单位计算出的数据段开始地址的偏移值。
* **选项（`options`）**：可选、不定长字段，该字段用于发送方和接收方协商最大报文段长度（`MSS`）时，或在高速网络环境下用作窗口调节因子。
* **标志（`flag`）**：长度为9bit，其中每个bit都是一个控制位。
  * SYN，为同步标志，用于数据同步；
  * ACK，为确认序号，ACK=1时确认号才有效；  
  * FIN，为结束序号，用于发送端提出断开连接；  
  * URG，为紧急序号，URG=1是紧急指针有效；  
  * PSH，指示接收方立即将数据提交给应用层，而不是等待缓冲区满；  
  * RST，重置连接；
  * NS，该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害；
  * ECE，ECN表示`Explicit Congestion Notification`，表示TCP peer有ECN能力；
  * CWR，发送者在接收到一个带有ECE flag包时，将会使用CWR 标志。

##### 序号和确认号

TCP 是[面向字节流](运输层.md#面向字节流)的，序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上，因此 **一个报文段的序号（`sequence number for a segment`）** 是该报文段首字节的字节流编号。

假设主机 A 上的一个进程想通过一条 TCP 连接向主机 B 上的一个进程发送一个数据流。主机中的 TCP 将隐式地对数据流中的每一个字节编号。假定数据流由一个包含 500, 000字节的文件组成，其 MSS 为1000字节，数据流的首字节编号是 `X` ，那么该 TCP 实体将为该数据流构建500个报文段，给第一个报文段分配序号 `X` ，给第二个报文段分配序号 `X + MSS * 1`，第 N 个报文段分配序号 `X + MSS * (N - 1)` 。

从上面例子可以看到，TCP 的确认号从一个随机的值开始，**这是为了提高安全性，也可以避免被相同端点之间早期连接的旧报文段混淆**。

**确认号是期望从另一方收到的下一个字节的序号**。与上文我们讨论的 rdt 不同的是，这里的确认号**多加了1**。

例如主机 A 已收到 一个来自主机 B 的包含字节 0 ~ 535 的报文段，以及另一个包含字节 900 ~ 1000 的报文段。由于某种原因，主机 A 还没有收到字节 536 ~ 899 的报文段。在这个例子中，主机 A 为了重新构建主机 B 的数据流，仍在等待字节 536 和其后的字节。因此，A 到 B 的下一个报文段将在确认号中包含 536。因为 TCP 只确认该流中至第一个丢失字节为止的字节，所以 TCP 被称为提供 **累积确认（`cumulative acknowledement`）** ，在这里和 [GBN](运输层.md#回退N步) 协议有些相似。

### TCP 可靠数据传输的实现

TCP 在 IP 不可靠的服务上创建了可靠数据传输服务。TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流。

#### TCP 发送方事件

TCP 发送方的三个主要事件分别是

1. 从应用层接收数据。
2. 超时。
3. 收到确认。

TCP 通过超时和重复确认两个事件触发重传。

当定时器超时，TCP 重传具有最小序号但仍未应答的报文段，此表现和 SR 协议相似。
当 TCP 收到多个重复的确认时，TCP 会执行[快速重传](运输层.md#快速重传)。

#### 快速重传

超时重传的问题之一是超时周期可能相对较长，会增加端到端时延。

我们通过冗余的 ACK 来检测报文段丢失，如果发送方接收到对于相同数据的3个冗余ACK，这说明跟在这个已被确认过三次的报文段之后的报文段很大可能已经丢失。我们在这种情况下执行 **快速重传（`fast retransmit`）** ，即在该报文段的定时器过期之前重传丢失的报文段。

### TCP 流量控制

TCP 提供了 **流量控制服务（`flow-control service`）** 以消除发送方使接收方缓存溢出的可能性。

TCP 通过让发送方维护一个称为 **接收窗口（`receive window`）** 的变量来提供流量控制，通俗地说，接收窗口用于给发送方提示该接收方还有多少可用的缓存空间。

由于 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。

假设主机 A 通过一条 TCP 连接向主机 B 发送一个文件。主机 B 为该连接分配了一个接收缓存，并用 `RevBuffer` 来表示其大小。主机 B 上的应用进程不时地从该缓存中读取数据。

我们定义：

* `LastByteRead` : 主机B 上的应用进程从缓存读出的数据流的最后一个字节的编号。
* `LastByteRcvd` : 从网络中到达的并且已经放入主机 B 接收缓存中的数据流的最后一个字节的编号。 

因为 TCP 不允许已分配的缓存溢出，所以有：

$$
LastByteRcvd - LastByteRead \leq RevBuffer
$$

那么接收窗口 `rwnd` 的值为：

$$
rwnd = RcvBuffer - \left[LastByteRcvd - LastByteRead\right]
$$

注意一种场景，当主机 B 的接收缓存已经存满，使得 rwnd = 0。这种情况下为了避免死锁问题，TCP 为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。** 如果持续计时器超时，就会发送 **窗口探测 ( Window probe )** 报文段，这个报文段只有一个字节的数据，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

### TCP 连接管理

#### TCP 建立连接

TCP 连接的创建过程通常被称为 **三次握手（`three-way handshake`）**。

![TCP 三次握手](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/tcp%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

一般地，客户端和服务端开始都处于 `CLOSED` 状态，服务端主动监听某个端口，状态变更为 `LISTEN` 状态。

第一步，客户端会发送一个 **SYN 报文段**。此报文段的 `SYN`  标志位置为 **1**，首部的序号字段由随机的初始序号（`client_isn`）填充，此报文段不包含任何应用层数据。在此报文段发送后，客户端 TCP 状态会变更到 `SYN_SENT`。

第二步，当服务端收到客户端的 **SYN 报文段** 后，服务端会为该 TCP 连接分配 TCP 缓存和变量， 并发送一个 **SYNACK报文段** 表达对连接请求的允许。此报文段的 `SYN`  和 `ACK` 标志位置为 **1** ，首部的序号字段由随机的初始序号（`server_isn`）填充，首部的确认号字段填入客户端的初始序号 + 1 （`client_isn + 1`），这个报文段也不包含任何应用层数据。在此报文段发送后，服务端 TCP 状态会变更到 `SYN_RCVD`。

第三步，在客户端收到 **SYNACK报文段** 后，客户端也需要为此 TCP 连接分配 TCP 缓存和变量，并发送一个应答报文对服务器的允许连接报文段进行了确认。此报文段的`ACK` 标志位置为 **1** ，`SYN` 标志位置为1，首部的序号字段是`client_isn + 1`，确认号字段是`server_isn + 1`。**注意，此报文段可以携带应用层数据**。发送此报文段后，客户端状态会变更为 `ESTABLISHED`，在服务端接收到此报文段后，服务端状态也会变更为 `ESTABLISHED`。

#### TCP 关闭连接

连接双方都可以主动断开连接，断开连接后主机中的资源（即缓存和变量）将被释放。TCP 断开连接的方式通常被称为 **四次挥手（`four-way handshake`）**。

![TCP 四次挥手](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/tcp%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

假设 TCP 客户端想要断开连接，它会发送一个 **FIN 报文段** ，此报文段的 `FIN` 标志位置为1，此后客户端进入 `FIN_WAIT_1` 状态。

服务端收到客户端的 **FIN 报文段** 后，就会向客户端发送 **ACK 报文段** ，此后服务端进入 `CLOSED_WAIT` 状态。客户端收到服务端的此 **ACK 报文段** 后，会进入 `FIN_WAIT_2` 状态。

等待服务端处理数据完成后，服务端会发送它自己的 **FIN 报文段** ，发送后服务端进入 `LAST_ACK` 阶段。客户端收到服务端的 **FIN 报文段** 后，客户端会回复自己的 **ACK 报文段** ，之后客户端进入 `TIME_WAIT` 状态。

服务器收到了 `ACK` 应答报文后，就进入了 `CLOSED` 状态，至此服务端已经完成连接的关闭，客户端在经过 `2MSL` 时间后，自动进入 `CLOSED` 状态，至此客户端也完成连接的关闭。

##### TIME_WAIT 状态的必要性

**MSL(`Maximum Segment Lifetime`)** 是 **报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

`TIME_WAIT` 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以 **一来一回需要等待 2 倍的时间**。

关于为什么 TCP 有 TIME_WAIT 状态，最主要的原因应该是 **保证连接关闭** 。只要客户端等待 2 MSL 的时间，客户端和服务端之间的连接就会正常关闭，新创建的 TCP 连接收到影响的概率也微乎其微，保证了数据传输的可靠性。
* ****

## 参考资料

* Kurose, J. F., & Ross, K. W. (2018). *计算机网络-自顶而下方法* (7th ed.). 机械工业出版社.
* [Wikipedia : User Datagram Protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)
* [Go-Back-N Protocol](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html)
* [Selective Repeat Protocol](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html)
* [Wikipedia : Transmission Control Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
* [为什么 TCP 协议有 TIME_WAIT 状态](https://draveness.me/whys-the-design-tcp-time-wait/)
