---
title: "运输层"
description: 
date: 2020-08-18T09:21:31+08:00
lastmod: 2020-09-01T22:13:24+08:00
image: 
math: 
license: MIT
hidden: false
comments: true
draft: false
tags: ["计算机网络"]
categories: ["计算机网络"]
---
## 一、概述

运输层协议为运行在不同主机上的应用进程之间提供了 **逻辑通信（`logic communication`）** 功能。

通过逻辑通信，运行不同进程的主机好像直接相连一样。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。

### 端口号

端口号是一个16比特的数，其大小在 0 ~ 65535 之间。

0 ~ 1023 范围的端口号称为 **周知端口号（`well-known port number`）** ，是受限制的，这些端口号一般保留给 HTTP 和 FTP 之类的周知应用层协议。

### 多路复用和多路分解

在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为 **多路复用（`multiplexing`）** 。

将运输层报文段中的数据交付到正确的套接字的工作称为 **多路分解（`demultiplexing`）** 。

#### 多路复用的实现

运输层多路复用的要求和实现对应是：

1. 套接字有唯一标识符 -- **源端口号字段（`source port number field`）**

2. 每个报文段有特殊字段来指示该报文段所要交付的字段 -- **目的端口号字段（`destination port number field`）**

#### 多路分解的实现

在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入所连接的进程。

## 二、UDP

UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。

### UDP 的特点

* **UDP 是无连接的，在两个进程通信前没有握手过程。** 因此 UDP 不会引入建立连接的时延。

* **UDP 没有连接状态。** 对应上一点提到的，因为 UDP 是无连接的，所以 UDP 不需要维护连接状态。

* **UDP 提供不可靠数据服务。** 当进程将一个报文发送进 UDP 套接字时，UDP 协议并不保证该报文将到达接收进程。除此之外，UDP 也不能保证报文的到达顺序，意味着到达接收进程的报文可能是乱序到达的。

* **应用层控制可以做到更加精细。** UDP 协议不包括拥塞控制策略，意味着 UDP 的发送端可以用选定的任意速率发送数据。应用层有着更大的实现自由，例如一些实时应用可以使用 UDP ，并作为应用的一部分来实现所需的、超出 UDP 的额外功能。

* **分组首部开销小。** 对比 TCP 协议有着20字节的首部开销，UDP 仅有8字节的首部开销。

### UDP 数据报结构

**UDP 数据报（`UDP datagram`）** 包含 **报头（`datagram header`）** 和 **数据字段(`data section`)** 两部分。

![UDP Datagram](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/UDP%20Datagram.png)

#### UDP 协议头

UDP 协议头包含4个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占16bit，即2个字节。

* **源端口** ：可选字段，它表示发送方进程的端口号，并且应假定为在需要时要回复的端口。
* **目的端口** ：必需字段，数据报接收方的端口号。
* **长度** ：协议头和数据报中数据的字节长度。最小长度为8字节，即标头的长度。
* **校验和**：用于协议头和数据的差错检测。在IPv4中可选，在IPv6中是必需的。

对于如下的一个使用 Wireshark 抓包的例子

![UDP header example](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-04-21%2008.27.44.png)

上述 UDP 首部中四个字段对应的值如下：

|   字段   |    数据     |
|:--------:|:-----------:|
|  源端口  | 0x1f5d=8029 |
| 目的端口 | 0x0747=1863 |
|   长度   |  0x0023=35  |
|  校验和  |   0x9019    |

#### UDP 校验和

UDP 校验和提供了差错检测功能，校验和用于确定当 UDP 报文段从源到目的地移动时，其中的比特是否发生了改变。

发送方的 UDP 对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都会被回卷，得到的结果放在校验和字段。

## 三、可靠数据传输

**可靠数据传输协议（`reliable data transfer protocol`）** 为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付。

我们从简单的场景渐渐过渡到复杂的场景，看如何实现可靠数据传输协议。

### 1. 经完全可靠信道的可靠数据传输：1.0

在这个场景下，我们假设底层信道是完全可靠的，并且接收端的接收速率可以和发送端的发送速率同步。

![rdt 1.0 fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063091894453.jpeg)

rdt 1.0 发送端在收到发送数据的事件（`rdt_send(data)`） 后，把数据分割成一个个分组，并开始发送数据。

rdt 1.0 接收端在收到接收数据的事件（`rdt_rcv(packet)`）后，从分组中提取数据，并把数据发送给上层。

### 2. 经具有比特差错信道的可靠数据传输：2.0

底层信道更为实际的模型是分组中的比特可能受损的模型。在这个场景下，我们还是假设发送的分组依然按序交付。

#### ARQ 协议的定义

在生活中两人打电话的场景也和此场景相近。假设 A 和 B 正在通电话，如果 A 说完一段话后，B 清楚地听到后会回复“好的”，如果 B 觉得 A 讲得含混不清，B 会回复 A “请重复一遍，我没听清”。回复“好的”可以视为 **肯定确认（`positive acknowledgment`）** ，回复“请重复一遍，我没听清楚”可以视为 **否定确认（`negative acknowledgment`）** 。

接收端可以通过这种方式使得发送端知道哪些内容被正确接收，哪些内容接收有误并需要重传。在计算机网络环境中，基于这种机制的可靠数据传输协议称为 **自动重传请求（`Automatic Repeat reQuest, ARQ`）协议** 。

#### ARQ 协议的实现

ARQ 协议需要三种协议功能来实现。

* **差错检测**
和 UDP 的[校验和](运输层.md#UDP%20校验和)功能实现类似，我们可以通过增加校验和字段的方式来实现差错检测。

* **接收方反馈**
在通电话场景下的 ACK （肯定确认） 和 NAK （否定确认）可以实现接收方反馈的功能。

* **重传**
接收方收到有差错的分组时，发送方将重传该分组。

![rdt 2.0 fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063177741459.jpeg)

当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，也即此时`rdt_send`事件不会发生。因此，除非发送端确认接收端已经正确地收到它当前发送的数据，发送端是不会发送新数据的。实现此类行为特征的协议被称为 **停等协议（`stop-and-wait protocol`）** 。

#### 处理ACK/NAK分组受损的场景

rdt 2.0 的实现没有考虑ACK或者NAK分组受损的可能性，在这种场景下，发送端无法知道接收端是否成功接收了上一块发送的数据。

我们的解决方案是在数据分组中增加一个新字段，让发送端对其数据分组编号，即将发送数据分组的 **序列号（`sequence number`）** 放在该字段。

rdt 2.0 作为停止等待协议的一个简单实现，序列号的长度是1位就够了。

![rdt 2.1 sender fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659653383.jpeg)

![rdt 2.1 receiver fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063659875543.jpeg)

rdt 2.1 在发送端和接收端均使用了 ACK/NAK，当接收端收到失序分组时，接收端发送 ACK 。当受损分组到达接收端时，接收端发送 NAK。

rdt 2.2 要做的改进是当受损分组到达接收端时，接收端不发送 NAK，取而代之的是发送一个对最近正确收到的数据的 ACK 。这时需要给 ACK 分组也添加序列号，当发送端收到这个 ACK 时，发送端可以根据 ACK 分组的序列号去判断这个 ACK 分组代表的是接收端正确接收了它刚发送的数据亦或是接收端正确接受了它上一次发送的数据。
当发送端收到两个对同一个分组确认的 ACK 时，即收到重复的 ACK ，发送端就可以知道接收端未能正确收到被确认两次的分组的下一个分组。

![rdt 2.2 sender fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063673825018.jpeg)

![rdt 2.2 receiver fsm](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063675189756.jpeg)

### 3. 经具有比特差错的丢包信道的可靠数据运输：3.0

这个场景下底层信道不但会产生比特受损外，还会有丢包的现象。所以协议现在必须处理另外两个关注的问题：

1. 怎么检测丢包
2. 发生丢包后如何处理

发送端可以选择一个合理的时间值，如果在这个时间段内，它没有收到这个分组的 ACK ，则重传该分组。即使在这种情况下引入了 **冗余数组分组（`duplicate data packet`）** 的可能性，但是 rdt 2.2 已经使用序列号处理冗余分组的情况。

实现基于时间的重传机制，需要一个 **倒计数定时器（`countdown timer`）** ，在一个给定的时间量过期后，可中断发送端。因此发送端需要以下功能：

1. 每次发送一个分组（包括第一次分组和重传分组），便启动一个定时器
2. 响应定时器中断（采取适当的动作）
3. 终止定时器

![rdt 3.0 fsm sender](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063717452835.jpeg)

因为分组序号在0和1之间交替，所以 rdt 3.0有时候被称为 **比特交替协议（`alternating-bit protocol`）** 。

### 4. 流水线可靠数据传输协议

rdt 3.0 采用的是停等协议，这样会导致信道的利用率很低，性能会非常差。

![pipelined protocol vs Stop-and-wait protocol](https://blog-1259169620.cos.ap-guangzhou.myqcloud.com/img/16063749150047.jpeg)

可以使用 **流水线（`pipelining`)** 技术使得分组可以同时发送，以提高性能。实现流水线技术的要点有：

1. **序列号的范围需要增加**，因为每个传送途中（非重传）的分组需要独一无二的序列号，而且同时可能存在多个在传送的未确认报文。
2. **发送端和接收端可能需要缓存多个分组**，发送端至少需要缓存那些已发送但是还未确认的分组，接收端可能需要缓存那些已经正确接收的分组。
3. 所需序列号范围和缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线的差错恢复有两种基本方法：
 a.  **回退 N 步（`Go-Back-N, GBN`）**
 b. **选择重传（`Selective Repeat, SR`）**

* ****

## 参考资料

* Kurose, J. F., & Ross, K. W. (2018). *计算机网络-自顶而下方法* (7th ed.). 机械工业出版社.
* [Wikipedia : User Datagram Protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)
